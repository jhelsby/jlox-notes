# 3. Parsing Expressions

In this section, we write a parser which can convert a sequence of tokens generated by our [scanner](/sections/1_scanning.md) into the syntax tree form we discussed in [Section 2](/sections/2_representing-code.md). To do this, we must:

* Make our grammar unambiguous. We can do this by defining a precedence and associativity for our operators, and a precedence for our grammar.
* Write our new grammar in a form we can easily implement. In this case, this means no [left recursion](https://en.wikipedia.org/wiki/Left_recursion), as this breaks top-down parsers.
* Write a [recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser) for our new grammar.

## An Unambiguous Grammar

### Precedence and Associativity

In [Section 2](/sections/2_representing-code.md), we defined the following grammar for our interpreter:
```
expression -> literal | unary | binary | grouping ;
literal    -> NUMBER | STRING | "true" | "false" | "nil" ;
grouping   -> "(" expression ")" ;
unary      -> ( "-" | "!" ) expression ;
binary     -> expression operator expression
operator   -> "==" | "!=" | "<" | "<=" | ">"
            | ">=" | "+"  | "-" | "*"  | "/" ;
```

Unfortunately, this grammar is ambiguous. For example, "1 / 2 + 3" is generated by both (1 / 2) + 3 or 1 / (2 + 3). To get around this, we need to define some more precise rules.

We define the following precedence and left- or right-associativity on our operators. Precedence is in increasing order, and follows [conventional order of operation rules](https://en.wikipedia.org/wiki/Order_of_operations#Conventional_order).

| Name | Operators | Associativity |
|-|-|-|
| Equality | `==` `!=` | Left |
| Comparison | `>` `>=` `<` `<=` | Left |
| Term | `-` `+` | Left |
| Factor | `/` `*` | Left |
| Unary | `!` `-` | Right |

To implement these, we can stratify our grammar accordingly. In order of ascending precendence:

| Expression | Operators |
|-|-|
| `expression` | everything |
| `equality` | `==` `!=` |
| `comparison` | `>` `>=` `<` `<=` |
| `term` | `-` `+` |
| `factor` | `/` `*` |
| `unary` | `!` `-` |
| `primary` | literals, parenthesised expressions |

Each expression here matches everything at its precedence level and higher. For example, everything is an `expression`, and `1 + 2` _and_ `1 * 2 / 3` are terms.

### Expressing Our Rules

Now, we can formalise our rules in [BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) as before. The only catch is that we will be implementing a [recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser),which doesn't support left recursion. This means that rules like:
```
factor -> factor ( "/" | "*" ) unary
```
will break our parser, because the method which would implements it via recursive descent would call itself infinitely and cause a stack overflow:
```java
Expr factor() {
    Expr left = factor(); // <- stack overflow here
    if (match(SLASH, STAR)) {
        Token operator previous();
        Expr right = unary();
    }
    return new Expr.Binary(left, operator, right);
}
```

With that in mind, here is our new, unambiguous grammar, implementing the precedence and associativity rules above, and avoiding left recursion:

```
expression -> equality ;
equality   -> comparison ( ( "!=" | "==" ) comparison )* ;
comparison -> term ( ( ">" | "?=" | "<" | "<=" ) term )* ;
term       -> factor ( ( "-" | "*" ) unary )* ;
factor     -> ( "!" | "-" ) unary | primary
primary    -> NUMBER | STRING | "true" | "false" | "nil" | "(" expression ")" ;
```

## Recursive Descent Parsing